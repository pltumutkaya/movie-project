<!DOCTYPE html>
<html lang="tr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Retro Fill+ — Qix/Silk Tarzı (Geliştirilmiş)</title>
    <style>
      :root {
        --bg: #0e0f16;
        --wall: #e9ecef;
        --empty: #141a24;
        --trail: #ffd46b;
        --player: #22d3ee;
        --enemy: #ff4d6d;
        --bar: #a78bfa;
        --bonus: #4ade80;
        --hud: #ffffff;
        --accent: #fbbf24;
        --shadow: 0 10px 34px rgba(0, 0, 0, 0.36);
      }
      html,
      body {
        height: 100%;
        margin: 0;
        background: #0a0c10;
        color: var(--hud);
        font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif;
      }
      .wrap {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
        padding: 12px;
        height: 100%;
      }
      canvas {
        background: var(--bg);
        border-radius: 14px;
        box-shadow: var(--shadow);
      }
      .hud {
        display: flex;
        gap: 14px;
        flex-wrap: wrap;
        align-items: center;
        justify-content: center;
      }
      .pill {
        padding: 0.35rem 0.65rem;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.08);
      }
      .btn {
        cursor: pointer;
        padding: 0.38rem 0.7rem;
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.15);
      }
      .title {
        font-weight: 800;
        letter-spacing: 0.5px;
        color: var(--accent);
      }
      .hint {
        opacity: 0.85;
        font-size: 0.92rem;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="hud">
        <span class="title">RETRO FILL+</span>
        <span class="pill" id="level">Seviye: 1</span>
        <span class="pill" id="score">Skor: 0</span>
        <span class="pill" id="lives">Can: 3</span>
        <span class="pill" id="filled">Doldurulan: 0%</span>
        <span class="pill">Hedef: <span id="goal">75%</span></span>
        <span class="pill">Düşman: <span id="enemies">1</span></span>
        <button class="btn" id="restart">Yeniden Başlat</button>
      </div>
      <canvas id="game" width="960" height="720"></canvas>
      <div class="hint">
        Yön tuşları/WASD: hareket • SPACE: çiz • ESC: iptal • P: duraklat •
        Bonus: <b>yeşil</b> • Elektrik çubuğu: <b>mor</b>
      </div>
    </div>

    <script>
      /* ==========================================================
   Retro Fill+ — Qix/Silk tarzı
   Ekler:
   - Çoklu düşman (seviye ile artar)
   - Sınır boyunca devriye gezen elektrik çubukları
   - Bonus (puan + kısa süreli kalkan)
   - Basit WebAudio sesleri
   ========================================================== */
      (() => {
        // ----------------- Oyun sabitleri -----------------
        const GRID_W = 128,
          GRID_H = 96; // mantıksal ızgara
        const TARGET_PERCENT = 75;
        const INITIAL_LIVES = 3;
        const BASE_ENEMY_SPEED = 5.0; // seviye ile artar
        const PLAYER_STEP_HZ = 12; // sn başına hücre adımı
        const SHIELD_TIME = 4.0; // bonus kalkan süresi (sn)
        const BONUS_PERIOD = 14.0; // bonus yenilenme
        const BAR_COUNT_BASE = 1; // elektrik çubuk sayısı (seviye ile artar)

        const EMPTY = 0,
          FILLED = 1,
          TRAIL = 2;

        // ----------------- Canvas / layout ----------------
        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d");
        const cellW = canvas.width / GRID_W;
        const cellH = canvas.height / GRID_H;

        function fitCanvas() {
          const maxW = Math.min(window.innerWidth - 20, 1200);
          const maxH = Math.min(window.innerHeight - 140, 900);
          const ar = canvas.width / canvas.height;
          let w = maxW,
            h = Math.floor(maxW / ar);
          if (h > maxH) {
            h = maxH;
            w = Math.floor(h * ar);
          }
          canvas.style.width = w + "px";
          canvas.style.height = h + "px";
        }
        window.addEventListener("resize", fitCanvas);
        fitCanvas();

        // ----------------- HUD ----------------------------
        const $level = document.getElementById("level");
        const $score = document.getElementById("score");
        const $lives = document.getElementById("lives");
        const $filled = document.getElementById("filled");
        const $goal = document.getElementById("goal");
        const $restart = document.getElementById("restart");
        const $enemies = document.getElementById("enemies");

        // ----------------- Ses (WebAudio) -----------------
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        const actx = new AudioCtx();
        let masterGain = actx.createGain();
        masterGain.gain.value = 0.12;
        masterGain.connect(actx.destination);

        function beep(freq = 440, dur = 0.08, type = "square") {
          const o = actx.createOscillator();
          const g = actx.createGain();
          o.type = type;
          o.frequency.value = freq;
          g.gain.value = 0.001;
          g.gain.setTargetAtTime(0.2, actx.currentTime, 0.005);
          o.connect(g);
          g.connect(masterGain);
          o.start();
          setTimeout(() => {
            g.gain.setTargetAtTime(0.0001, actx.currentTime, 0.02);
            o.stop(actx.currentTime + 0.05);
          }, dur * 1000);
        }

        // ----------------- Durum --------------------------
        let grid,
          level,
          score,
          lives,
          goalPercent,
          paused = false;
        let player,
          drawing = false,
          keys = {},
          dir = { x: 0, y: 0 },
          playerMoveAccum = 0;
        let enemies = [],
          bars = [],
          bonus = null,
          shield = 0,
          bonusTimer = 0;
        let filledPercent = 0;

        const inBounds = (x, y) => x >= 0 && x < GRID_W && y >= 0 && y < GRID_H;
        const idx = (x, y) => y * GRID_W + x;

        function resetGame() {
          level = 1;
          score = 0;
          lives = INITIAL_LIVES;
          goalPercent = TARGET_PERCENT;
          shield = 0;
          initLevel();
        }

        function initLevel() {
          grid = new Uint8Array(GRID_W * GRID_H);
          for (let x = 0; x < GRID_W; x++) {
            grid[idx(x, 0)] = FILLED;
            grid[idx(x, GRID_H - 1)] = FILLED;
          }
          for (let y = 0; y < GRID_H; y++) {
            grid[idx(0, y)] = FILLED;
            grid[idx(GRID_W - 1, y)] = FILLED;
          }
          player = { x: Math.floor(GRID_W / 2), y: GRID_H - 1, speed: 1 };

          // Düşmanlar
          const enemyCount = Math.min(1 + Math.floor((level - 1) / 1), 6);
          enemies = [];
          for (let i = 0; i < enemyCount; i++) {
            enemies.push({
              x: GRID_W * (0.35 + 0.3 * Math.random()),
              y: GRID_H * (0.35 + 0.3 * Math.random()),
              vx:
                (Math.random() < 0.5 ? 1 : -1) *
                (BASE_ENEMY_SPEED + level * 0.8 + i * 0.5),
              vy:
                (Math.random() < 0.5 ? 1 : -1) *
                (BASE_ENEMY_SPEED + level * 0.8 + i * 0.5),
              r: Math.min(cellW, cellH) * 0.45,
            });
          }

          // Elektrik çubukları (sınır devriye)
          const barCount = Math.min(BAR_COUNT_BASE + Math.floor(level / 2), 6);
          bars = [];
          for (let i = 0; i < barCount; i++) {
            bars.push({
              t: Math.random(), // 0..1 çevrede konum
              speed: 0.06 + level * 0.01 + i * 0.005, // çevre boyunca hız
              len: 0.1, // çevrenin yüzdesi kadar uzunluk
              phase: Math.random() < 0.5 ? 1 : -1,
            });
          }

          // Bonus
          bonusTimer = 1.5; // ilk bonus kısa sürede gelsin
          bonus = null;

          computeFilledPercent();
          updateHUD();
          $enemies.textContent = enemies.length;
        }

        function updateHUD() {
          $level.textContent = `Seviye: ${level}`;
          $score.textContent = `Skor: ${score}`;
          $lives.textContent = `Can: ${lives}`;
          $goal.textContent = `${goalPercent}%`;
          $filled.textContent = `Doldurulan: ${Math.floor(filledPercent)}%`;
        }

        // ----------------- Giriş --------------------------
        window.addEventListener(
          "keydown",
          (e) => {
            if (actx.state === "suspended") actx.resume(); // ilk etkileşimde ses için
            if (e.key === "p" || e.key === "P") {
              paused = !paused;
              return;
            }
            if (e.key === "Escape") {
              if (drawing) cancelTrail();
              return;
            }
            if (e.code === "Space") {
              drawing = true;
              return;
            }
            keys[e.key.toLowerCase()] = true;
            e.preventDefault();
          },
          { passive: false }
        );
        window.addEventListener("keyup", (e) => {
          keys[e.key.toLowerCase()] = false;
        });
        document.getElementById("restart").onclick = () => resetGame();

        function calcDir() {
          let dx = 0,
            dy = 0;
          if (keys["arrowleft"] || keys["a"]) dx = -1;
          if (keys["arrowright"] || keys["d"]) dx = 1;
          if (keys["arrowup"] || keys["w"]) dy = -1;
          if (keys["arrowdown"] || keys["s"]) dy = 1;
          if (dx && dy) dy = 0; // tek eksen
          return { x: dx, y: dy };
        }

        function cancelTrail() {
          for (let i = 0; i < grid.length; i++)
            if (grid[i] === TRAIL) grid[i] = EMPTY;
          drawing = false;
          beep(180, 0.06, "sawtooth");
        }

        // ----------------- Oyun Mantığı -------------------
        function updatePlayer(dt) {
          dir = calcDir();
          playerMoveAccum += dt * player.speed * PLAYER_STEP_HZ;
          while (playerMoveAccum >= 1) {
            const nx = Math.max(0, Math.min(GRID_W - 1, player.x + dir.x));
            const ny = Math.max(0, Math.min(GRID_H - 1, player.y + dir.y));
            if (nx === player.x && ny === player.y) break;
            const at = grid[idx(nx, ny)];
            if (!drawing) {
              if (at === FILLED) {
                player.x = nx;
                player.y = ny;
              }
            } else {
              if (at === FILLED) {
                finalizeTrailAndFill();
                drawing = false;
                break;
              } else {
                grid[idx(nx, ny)] = TRAIL;
                player.x = nx;
                player.y = ny;
              }
            }
            playerMoveAccum -= 1;
          }
          // Bonus temas
          if (bonus && player.x === bonus.x && player.y === bonus.y) {
            score += 300;
            shield = SHIELD_TIME;
            bonus = null;
            beep(880, 0.12, "triangle");
          }
        }

        function updateEnemies(dt) {
          for (const e of enemies) {
            e.x += e.vx * dt * (GRID_W / 60) * 0.6;
            e.y += e.vy * dt * (GRID_H / 60) * 0.6;
            if (e.x < 1) {
              e.x = 1;
              e.vx *= -1;
            }
            if (e.x > GRID_W - 2) {
              e.x = GRID_W - 2;
              e.vx *= -1;
            }
            if (e.y < 1) {
              e.y = 1;
              e.vy *= -1;
            }
            if (e.y > GRID_H - 2) {
              e.y = GRID_H - 2;
              e.vy *= -1;
            }

            const ex = Math.round(e.x),
              ey = Math.round(e.y);
            if (
              inBounds(ex, ey) &&
              grid[idx(ex, ey)] === TRAIL &&
              shield <= 0
            ) {
              loseLife();
              break;
            }
          }
        }

        // Elektrik çubukları çevre üzerinde gezsin.
        // Perimetre koordinatı s in [0,1): 0..1 boyunca kenarlar dolaşılır.
        function perimToXY(s) {
          const perW = GRID_W - 1,
            perH = GRID_H - 1;
          const P = 2 * (perW + perH);
          let d = s * P;

          if (d < perW) return { x: Math.round(d), y: 0 };
          d -= perW;
          if (d < perH) return { x: perW, y: Math.round(d) };
          d -= perH;
          if (d < perW) return { x: perW - Math.round(d), y: perH };
          d -= perW;
          return { x: 0, y: perH - Math.round(d) };
        }

        function updateBars(dt) {
          for (const b of bars) {
            b.t += b.speed * dt * b.phase;
            if (b.t < 0) b.t = 1 + b.t;
            if (b.t >= 1) b.t -= 1;

            // Çubuğun kapladığı kenar parçasındaki hücrelere yakınsan ve FILLED üzerindeysen temas say
            const steps = Math.max(
              3,
              Math.floor(b.len * (2 * (GRID_W + GRID_H)))
            );
            for (let i = 0; i < steps; i++) {
              const s = (b.t + (i / steps) * b.len) % 1;
              const p = perimToXY(s);
              if (
                player.x === p.x &&
                player.y === p.y &&
                grid[idx(player.x, player.y)] === FILLED &&
                shield <= 0
              ) {
                loseLife();
                return;
              }
            }
          }
        }

        function spawnBonus() {
          // doldurulmamış güvenli bir noktada belirsin
          for (let tries = 0; tries < 200; tries++) {
            const x = 2 + Math.floor(Math.random() * (GRID_W - 4));
            const y = 2 + Math.floor(Math.random() * (GRID_H - 4));
            if (grid[idx(x, y)] === EMPTY) {
              bonus = { x, y };
              return;
            }
          }
        }

        function updateBonus(dt) {
          bonusTimer -= dt;
          if (bonusTimer <= 0) {
            bonusTimer = BONUS_PERIOD + Math.random() * 6;
            spawnBonus();
          }
        }

        function loseLife() {
          if (shield > 0) return; // kalkan açıkken görmezden gel
          lives--;
          beep(140, 0.1, "sawtooth");
          beep(110, 0.12, "sawtooth");
          // trail temizle
          for (let i = 0; i < grid.length; i++)
            if (grid[i] === TRAIL) grid[i] = EMPTY;
          drawing = false;
          // oyuncuyu alt kenara çek
          player.x = Math.min(GRID_W - 2, Math.max(1, player.x));
          player.y = GRID_H - 1;
          if (lives <= 0) {
            gameOver();
          }
          updateHUD();
        }

        function gameOver() {
          paused = true;
          toast("Oyun Bitti! Yeniden başlatabilirsin.");
        }

        function finalizeTrailAndFill() {
          // trail -> duvar
          for (let i = 0; i < grid.length; i++)
            if (grid[i] === TRAIL) grid[i] = FILLED;

          // düşmanların bulunduğu bölgeler erişilebilir olsun
          const reach = new Uint8Array(grid.length);
          const qx = [],
            qy = [];
          for (const e of enemies) {
            const sx = Math.round(Math.max(1, Math.min(GRID_W - 2, e.x)));
            const sy = Math.round(Math.max(1, Math.min(GRID_H - 2, e.y)));
            if (grid[idx(sx, sy)] !== FILLED && reach[idx(sx, sy)] === 0) {
              qx.push(sx);
              qy.push(sy);
              reach[idx(sx, sy)] = 1;
            }
          }
          const nbs = [
            [1, 0],
            [-1, 0],
            [0, 1],
            [0, -1],
          ];
          while (qx.length) {
            const x = qx.pop(),
              y = qy.pop();
            for (const [dx, dy] of nbs) {
              const nx = x + dx,
                ny = y + dy;
              if (!inBounds(nx, ny)) continue;
              const id = idx(nx, ny);
              if (reach[id] || grid[id] !== EMPTY) continue;
              reach[id] = 1;
              qx.push(nx);
              qy.push(ny);
            }
          }

          // erişilemeyen boşlukları doldur
          let newly = 0;
          for (let i = 0; i < grid.length; i++) {
            if (grid[i] === EMPTY && reach[i] === 0) {
              grid[i] = FILLED;
              newly++;
            }
          }
          score += 50 + newly;
          beep(740, 0.06, "triangle");
          beep(980, 0.08, "triangle");

          computeFilledPercent();
          updateHUD();
          if (filledPercent >= goalPercent) nextLevel();
        }

        function computeFilledPercent() {
          let f = 0;
          for (let i = 0; i < grid.length; i++) if (grid[i] === FILLED) f++;
          filledPercent = (100 * f) / grid.length;
        }

        function nextLevel() {
          level++;
          score += 1000;
          goalPercent = Math.min(90, TARGET_PERCENT + (level - 1) * 3);
          toast(`Seviye ${level}! Hedef %${goalPercent}`);
          initLevel();
        }

        // ----------------- Çizim --------------------------
        function draw() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          // Hücreler
          for (let y = 0; y < GRID_H; y++) {
            for (let x = 0; x < GRID_W; x++) {
              const v = grid[idx(x, y)];
              if (v === EMPTY) ctx.fillStyle = getCSS("--empty");
              else if (v === FILLED) ctx.fillStyle = getCSS("--wall");
              else ctx.fillStyle = getCSS("--trail");
              ctx.fillRect(
                x * cellW,
                y * cellH,
                Math.ceil(cellW),
                Math.ceil(cellH)
              );
            }
          }

          // Bonus
          if (bonus) {
            ctx.fillStyle = getCSS("--bonus");
            ctx.fillRect(
              bonus.x * cellW,
              bonus.y * cellH,
              Math.ceil(cellW),
              Math.ceil(cellH)
            );
          }

          // Oyuncu
          ctx.fillStyle = getCSS("--player");
          ctx.fillRect(
            player.x * cellW,
            player.y * cellH,
            Math.ceil(cellW),
            Math.ceil(cellH)
          );

          // Düşmanlar
          ctx.fillStyle = getCSS("--enemy");
          for (const e of enemies) {
            ctx.beginPath();
            ctx.arc(
              e.x * cellW + cellW / 2,
              e.y * cellH + cellH / 2,
              Math.min(cellW, cellH) * 0.45,
              0,
              Math.PI * 2
            );
            ctx.fill();
          }

          // Elektrik çubukları
          ctx.strokeStyle = getCSS("--bar");
          ctx.lineWidth = Math.max(2, Math.min(cellW, cellH) * 0.6);
          for (const b of bars) {
            const steps = Math.max(
              3,
              Math.floor(b.len * (2 * (GRID_W + GRID_H)))
            );
            for (let i = 0; i < steps; i++) {
              const s = (b.t + (i / steps) * b.len) % 1;
              const p = perimToXY(s);
              ctx.beginPath();
              ctx.moveTo(p.x * cellW + cellW / 2, p.y * cellH + cellH / 2);
              ctx.lineTo(p.x * cellW + cellW / 2, p.y * cellH + cellH / 2);
              ctx.stroke();
            }
          }

          // İlerleme barı
          progressBar();
          // Kalkan göstergesi
          if (shield > 0) {
            ctx.save();
            ctx.globalAlpha = 0.25;
            ctx.fillStyle = "#00e1ff";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.restore();
          }
        }

        function progressBar() {
          const pad = 10,
            barW = canvas.width - pad * 2,
            barH = 10;
          ctx.fillStyle = "rgba(255,255,255,.15)";
          ctx.fillRect(pad, pad, barW, barH);
          ctx.fillStyle = getCSS("--accent");
          ctx.fillRect(pad, pad, barW * Math.min(1, filledPercent / 100), barH);
          ctx.strokeStyle = "rgba(255,255,255,.35)";
          ctx.strokeRect(pad + 0.5, pad + 0.5, barW - 1, barH - 1);
        }

        function getCSS(name) {
          return getComputedStyle(document.documentElement).getPropertyValue(
            name
          );
        }

        // ----------------- Toast --------------------------
        let toastTimer = 0;
        function toast(msg) {
          clearTimeout(toastTimer);
          const x = canvas.width / 2,
            y = canvas.height * 0.5;
          let t = 0,
            dur = 1800;
          (function anim() {
            if (t > dur) return;
            draw();
            ctx.save();
            ctx.font = "bold 32px system-ui,Segoe UI,Roboto";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillStyle = "rgba(0,0,0,.45)";
            ctx.fillRect(x - 360, y - 38, 720, 76);
            ctx.fillStyle = "#fff";
            ctx.fillText(msg, x, y);
            ctx.restore();
            t += 16;
            requestAnimationFrame(anim);
          })();
          toastTimer = setTimeout(() => {}, dur);
        }

        // ----------------- Döngü --------------------------
        let last = performance.now();
        function loop(now) {
          const dt = Math.min(0.05, (now - last) / 1000);
          last = now;
          if (!paused) {
            shield = Math.max(0, shield - dt);
            updatePlayer(dt);
            updateEnemies(dt);
            updateBars(dt);
            updateBonus(dt);
            draw();
          }
          requestAnimationFrame(loop);
        }

        resetGame();
        requestAnimationFrame(loop);
      })();
    </script>
  </body>
</html>
